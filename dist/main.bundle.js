module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/server.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/Connection.js":
/*!***************************!*\
  !*** ./src/Connection.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _http = __webpack_require__(/*! http */ \"http\");\n\nvar _http2 = _interopRequireDefault(_http);\n\nvar _socket = __webpack_require__(/*! socket.io */ \"socket.io\");\n\nvar _socket2 = _interopRequireDefault(_socket);\n\nvar _fs = __webpack_require__(/*! fs */ \"fs\");\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _url = __webpack_require__(/*! url */ \"url\");\n\nvar _url2 = _interopRequireDefault(_url);\n\nvar _path = __webpack_require__(/*! path */ \"path\");\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _mysql = __webpack_require__(/*! mysql */ \"mysql\");\n\nvar _mysql2 = _interopRequireDefault(_mysql);\n\nvar _setting = __webpack_require__(/*! ./setting */ \"./src/setting.js\");\n\nvar _setting2 = _interopRequireDefault(_setting);\n\nvar _RoomList = __webpack_require__(/*! ./RoomList */ \"./src/RoomList.js\");\n\nvar _RoomList2 = _interopRequireDefault(_RoomList);\n\nvar _UserList = __webpack_require__(/*! ./UserList */ \"./src/UserList.js\");\n\nvar _UserList2 = _interopRequireDefault(_UserList);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Connection = function () {\n  function Connection() {\n    _classCallCheck(this, Connection);\n  }\n\n  // Setup\n\n\n  _createClass(Connection, [{\n    key: \"setup\",\n    value: function setup() {\n\n      this.app = _http2.default.createServer(this._onRequest);\n      this.io = (0, _socket2.default)(this.app);\n      this.db = _mysql2.default.createConnection(_setting2.default.db);\n\n      this.app.listen(3000);\n      this.db.connect();\n\n      // game room list\n      this.rooms = new _RoomList2.default();\n\n      // game user list\n      this.users = new _UserList2.default();\n    }\n\n    // url handler\n\n  }, {\n    key: \"_onRequest\",\n    value: function _onRequest(req, res) {\n\n      var pathname = _url2.default.parse(req.url).pathname;\n      var ext = _path2.default.parse(pathname).ext;\n\n      if (pathname == \"/\") {\n        pathname = \"/index.html\";\n      }\n\n      _fs2.default.readFile(pathname, function (err, data) {\n\n        if (err) {\n          console.log(err);\n          res.writeHead(404, { \"Content-Type\": \"text/html\" });\n          res.write(err.toString());\n        } else if (ext == \".css\") {\n          res.writeHead(200, { \"Content-Type\": \"text/css\" });\n          res.write(data);\n        } else if (ext == \".js\") {\n          res.writeHead(200, { \"Content-Type\": \"text/javascript\" });\n          res.write(data);\n        } else {\n          res.writeHead(200, { \"Content-Type\": \"text/html\" });\n          res.write(data);\n        }\n        res.end();\n      });\n    }\n  }]);\n\n  return Connection;\n}();\n\nexports.default = new Connection();\n\n//# sourceURL=webpack:///./src/Connection.js?");

/***/ }),

/***/ "./src/QueryHandler.js":
/*!*****************************!*\
  !*** ./src/QueryHandler.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar QuaryHandler = function () {\n  function QuaryHandler() {\n    _classCallCheck(this, QuaryHandler);\n  }\n\n  _createClass(QuaryHandler, null, [{\n    key: \"selectQuery\",\n    value: function selectQuery(connnectionData, queryData, callback) {\n\n      // make query statement\n      var queryText = \"SELECT * FROM \" + queryData.table;\n      if (queryData.condition) queryText += \" WHERE \" + queryData.condition;\n\n      // conduct query statement\n      connnectionData.db.query(queryText, function (error, results, fields) {\n        if (error) throw error;\n        if (typeof callback === \"function\") callback(results, connnectionData);\n      });\n    }\n  }, {\n    key: \"insertQuery\",\n    value: function insertQuery(connnectionData, queryData, callback) {\n\n      // make query statement\n      var queryText = \"INSERT INTO \" + queryData.table + \" SET ?\";\n\n      // conduct query statement\n      connnectionData.db.query(queryText, queryData.contents, function (error, results, fields) {\n        if (error) throw error;\n        if (typeof callback === \"function\") callback(results, connnectionData);\n      });\n    }\n  }, {\n    key: \"updateQuery\",\n    value: function updateQuery(connnectionData, queryData, callback) {\n\n      // make query statement\n      var queryText = \"UPDATE \" + queryData.table + \" SET ? WHERE \" + queryData.condition;\n\n      // conduct query statement\n      connnectionData.db.query(queryText, queryData.contents, function (error, results, fields) {\n        if (error) throw error;\n        if (typeof callback === \"function\") callback(results, connnectionData);\n      });\n    }\n  }]);\n\n  return QuaryHandler;\n}();\n\nexports.default = QuaryHandler;\n\n//# sourceURL=webpack:///./src/QueryHandler.js?");

/***/ }),

/***/ "./src/Room.js":
/*!*********************!*\
  !*** ./src/Room.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nvar _crypto2 = _interopRequireDefault(_crypto);\n\nvar _Connection = __webpack_require__(/*! ./Connection */ \"./src/Connection.js\");\n\nvar _Connection2 = _interopRequireDefault(_Connection);\n\nvar _Party = __webpack_require__(/*! ./cli-core/Party.js */ \"./src/cli-core/Party.js\");\n\nvar _Party2 = _interopRequireDefault(_Party);\n\nvar _Stage = __webpack_require__(/*! ./cli-core/Stage.js */ \"./src/cli-core/Stage.js\");\n\nvar _Stage2 = _interopRequireDefault(_Stage);\n\nvar _StageData = __webpack_require__(/*! ./cli-core/StageData.js */ \"./src/cli-core/StageData.js\");\n\nvar _StageData2 = _interopRequireDefault(_StageData);\n\nvar _Character = __webpack_require__(/*! ./cli-core/Character.js */ \"./src/cli-core/Character.js\");\n\nvar _Character2 = _interopRequireDefault(_Character);\n\nvar _CharacterData = __webpack_require__(/*! ./cli-core/CharacterData.js */ \"./src/cli-core/CharacterData.js\");\n\nvar _CharacterData2 = _interopRequireDefault(_CharacterData);\n\nvar _Configuration = __webpack_require__(/*! ./cli-core/Configuration.js */ \"./src/cli-core/Configuration.js\");\n\nvar _Configuration2 = _interopRequireDefault(_Configuration);\n\nvar _PartySimulator = __webpack_require__(/*! ./cli-core/PartySimulator.js */ \"./src/cli-core/PartySimulator.js\");\n\nvar _PartySimulator2 = _interopRequireDefault(_PartySimulator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Room = function () {\n  function Room(id, counts, team, players) {\n    _classCallCheck(this, Room);\n\n    this.id = id;\n    this.playerCounts = counts;\n    this.isTeamGame = team;\n    this.seed = _crypto2.default.randomBytes(16).toString('hex');\n\n    this.players = players;\n    this.leftPlayers = [];\n    this.aiPlayers = [];\n\n    this._initialize();\n  }\n\n  _createClass(Room, [{\n    key: \"_initialize\",\n    value: function _initialize() {\n      var _this = this;\n\n      // Create a stage\n      this.stageData = new _StageData2.default(this.seed);\n      this.stage = new _Stage2.default(this.stageData);\n      this.stage.roomId = this.id;\n\n      var idList = [1, 2, 3, 4];\n      // let colorList = [0x008744, 0x0057e7, 0xd62d20, 0xffa700];\n\n      // Create player parties\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.players[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var player = _step.value;\n\n\n          var partyId = this._pickId(idList);\n          var party = new _Party2.default(player.id, partyId, this._getColor(partyId));\n\n          for (var i = 0; i < 3; i++) {\n            var characterData = new _CharacterData2.default();\n            var character = new _Character2.default(characterData);\n            party.addMember(character);\n          }\n\n          party.roomId = this.id;\n\n          this.stage.addParty(party);\n        }\n\n        // Create ai parties\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var _loop = function _loop(i) {\n\n        var partyId = _this._pickId(idList);\n        var party = new _Party2.default(\"\", partyId, _this._getColor(partyId));\n        var ai = new _PartySimulator2.default(party);\n\n        ai.setEnvironment(_this.stage.territory, _this.stage.meta.obstacles);\n        ai.onAction(function (direction, coord, tgt) {\n          party.scheduleDirection(direction);\n        });\n        _this.aiPlayers.push(ai);\n\n        for (var _i = 0; _i < 3; _i++) {\n          var _characterData = new _CharacterData2.default();\n          var _character = new _Character2.default(_characterData);\n          party.addMember(_character);\n        }\n\n        party.roomId = _this.id;\n\n        _this.stage.addParty(party);\n      };\n\n      for (var i = 0; i < this.playerCounts - this.players.length; i++) {\n        _loop(i);\n      }\n\n      // add parties to stage\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.stage.parties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _party = _step2.value;\n\n          var startCoordinate = this._getStartCoordinate(_party.id);\n          _party.setStartCoordinate(startCoordinate.x, startCoordinate.y, (_party.id + 1) % 4);\n          _party.displaceToStartCoordinate();\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_pickId\",\n    value: function _pickId(idList) {\n      var idx = Math.floor(Math.random() * idList.length);\n      var id = idList[idx];\n      idList.splice(idx, 1);\n      return id;\n    }\n  }, {\n    key: \"_getColor\",\n    value: function _getColor(partyId) {\n      switch (partyId) {\n        case 1:\n          return 0x008744;\n        case 2:\n          return 0x0057e7;\n        case 3:\n          return 0xd62d20;\n        case 4:\n          return 0xffa700;\n      }\n    }\n  }, {\n    key: \"_getStartCoordinate\",\n    value: function _getStartCoordinate(partyId) {\n      switch (partyId) {\n        case 1:\n          return { x: this.stage.meta.dimension.width - 1, y: 0 };\n        case 2:\n          return { x: 0, y: 0 };\n        case 3:\n          return { x: 0, y: this.stage.meta.dimension.height - 1 };\n        case 4:\n          return {\n            x: this.stage.meta.dimension.width - 1,\n            y: this.stage.meta.dimension.height - 1\n          };\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(deltaTime) {\n      for (var i = 0; i < this.aiPlayers.length; i++) {\n        this.aiPlayers[i].update(deltaTime);\n      }\n\n      this.stage.update(deltaTime);\n    }\n  }, {\n    key: \"broadcast\",\n    value: function broadcast(event, data) {\n      var notMeId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n\n        for (var _iterator3 = this.players[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var player = _step3.value;\n\n          if (player.socketId && player.id != notMeId) _Connection2.default.io.to(player.socketId).emit(event, data);\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"connectedPlayers\",\n    value: function connectedPlayers() {\n\n      var userList = [];\n\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = this.players[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var player = _step4.value;\n\n          if (player.socketId) userList.push(player);\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      return userList;\n    }\n  }, {\n    key: \"deleteUserFromRoom\",\n    value: function deleteUserFromRoom(userId) {\n      for (var i in this.players) {\n        if (this.players[i].id == userId) {\n          this.deleteUserFromStage(this.players[i]);\n          this.players.splice(i, 1);\n          this.leftPlayers.push(this.players[i]);\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"deleteUserFromStage\",\n    value: function deleteUserFromStage(userId) {\n      for (var i in this.stage.parties) {\n        if (this.stage.parties[i].id == userId) {\n          this.stage.parties.splice(i, 1);\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"endProcess\",\n    value: function endProcess() {}\n  }]);\n\n  return Room;\n}();\n\nexports.default = Room;\n\n//# sourceURL=webpack:///./src/Room.js?");

/***/ }),

/***/ "./src/RoomList.js":
/*!*************************!*\
  !*** ./src/RoomList.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nvar _crypto2 = _interopRequireDefault(_crypto);\n\nvar _Room = __webpack_require__(/*! ./Room */ \"./src/Room.js\");\n\nvar _Room2 = _interopRequireDefault(_Room);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar RoomList = function () {\n  function RoomList() {\n    _classCallCheck(this, RoomList);\n\n    this.roomIdMap = new Map();\n    this.roomList = [];\n  }\n\n  _createClass(RoomList, [{\n    key: \"create\",\n    value: function create(counts, team, players) {\n      var room = new _Room2.default(this._generateUid(), counts, team, players);\n      this.roomIdMap.set(room.id, room);\n      this.roomList.push(room);\n      return room;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(roomId) {\n\n      var room = this.getById(roomId);\n      if (room) {\n        // room.close();\n        this.roomList.splice(this.roomList.indexOf(room), 1);\n        this.roomIdMap.delete(room.id);\n      }\n    }\n  }, {\n    key: \"exists\",\n    value: function exists(roomId) {\n      return this.roomIdMap.has(roomId);\n    }\n  }, {\n    key: \"getById\",\n    value: function getById(roomId) {\n      return this.roomIdMap.get(roomId);\n    }\n  }, {\n    key: \"update\",\n    value: function update(deltaTime) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.roomList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var room = _step.value;\n\n          room.update(deltaTime);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_generateUid\",\n    value: function _generateUid() {\n      var uid = void 0;\n      do {\n        uid = _crypto2.default.createHash('sha256').update(Math.random().toString(36)).digest('hex').slice(0, 20);\n      } while (this.roomIdMap.has(uid));\n      return uid;\n    }\n  }]);\n\n  return RoomList;\n}();\n\nexports.default = RoomList;\n\n//# sourceURL=webpack:///./src/RoomList.js?");

/***/ }),

/***/ "./src/UpdateHandler.js":
/*!******************************!*\
  !*** ./src/UpdateHandler.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mysql = __webpack_require__(/*! mysql */ \"mysql\");\n\nvar _mysql2 = _interopRequireDefault(_mysql);\n\nvar _QueryHandler = __webpack_require__(/*! ./QueryHandler */ \"./src/QueryHandler.js\");\n\nvar _QueryHandler2 = _interopRequireDefault(_QueryHandler);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar UpdateHandler = function () {\n  function UpdateHandler() {\n    _classCallCheck(this, UpdateHandler);\n  }\n\n  _createClass(UpdateHandler, null, [{\n    key: \"signUp\",\n    value: function signUp(results, connnectionData) {\n\n      // same id check\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = results[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var result = _step.value;\n\n          if (result.user_id === connnectionData.data.id) {\n            connnectionData.socket.emit(\"creat user\", {\n              success: false,\n              error: \"same id\"\n            });\n            return;\n          }\n        }\n\n        // insert new user at user related tables\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      _QueryHandler2.default.insertQuery(connnectionData, {\n        table: \"user\",\n        contents: {\n          user_id: connnectionData.data.id,\n          password: connnectionData.data.password,\n          first_login: _mysql2.default.raw(\"NOW()\"),\n          last_login: _mysql2.default.raw(\"NOW()\")\n        }\n      });\n\n      _QueryHandler2.default.insertQuery(connnectionData, {\n        table: \"user_gamedata\",\n        contents: {\n          user_id: connnectionData.data.id\n        }\n      });\n\n      _QueryHandler2.default.insertQuery(connnectionData, {\n        table: \"user_gamestat\",\n        contents: {\n          user_id: connnectionData.data.id\n        }\n      });\n\n      // sign up complete\n      connnectionData.socket.emit(\"creat user\", {\n        success: true\n      });\n    }\n  }, {\n    key: \"signIn\",\n    value: function signIn(results, connnectionData) {\n\n      // auto sign in check\n      if (connnectionData.data.isAuto) {\n\n        var len = results.length;\n\n        // enough accounts check\n        if (len === connnectionData.users.userList.length) {\n          connnectionData.socket.emit(\"establish session\", {\n            success: false,\n            error: \"not enough accounts\"\n          });\n          return;\n        }\n\n        var newUser = void 0;\n        do {\n          newUser = results[Math.min(Math.floor(len * Math.random()), len)];\n        } while (connnectionData.users.exists(newUser.user_id));\n\n        // register user in users(user list)\n        connnectionData.users.register(newUser.user_id, \"ready\", connnectionData.socket.id);\n\n        // update last_login in database\n        _QueryHandler2.default.updateQuery(connnectionData, {\n          table: \"user\",\n          contents: { last_login: _mysql2.default.raw(\"NOW()\") },\n          condition: \"id = \" + newUser.id\n        });\n\n        // send sign in complete\n        connnectionData.socket.emit(\"establish session\", {\n          success: true,\n          userId: newUser.user_id\n        });\n\n        console.log(\"user <%s> connected\", newUser.user_id);\n\n        return;\n      }\n\n      // id & password check\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = results[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var result = _step2.value;\n\n          if (result.user_id === connnectionData.data.id) {\n            if (result.password === connnectionData.data.password) {\n\n              // double sign in check\n              if (connnectionData.users.exists(connnectionData.data.id)) {\n                connnectionData.socket.emit(\"establish session\", {\n                  success: false,\n                  error: \"already signed\"\n                });\n                return;\n              }\n\n              // register user in users(user list)\n              connnectionData.users.register(connnectionData.data.id, \"ready\", connnectionData.socket.id);\n\n              // update last_login in database\n              _QueryHandler2.default.updateQuery(connnectionData, {\n                table: \"user\",\n                contents: { last_login: _mysql2.default.raw(\"NOW()\") },\n                condition: \"id = \" + result.id\n              });\n\n              // send sign in complete\n              connnectionData.socket.emit(\"establish session\", {\n                success: true,\n                userId: connnectionData.data.id\n              });\n\n              console.log(\"user <%s> connected\", connnectionData.data.id);\n\n              return;\n            } else {\n\n              connnectionData.socket.emit(\"establish session\", {\n                success: false,\n                error: \"wrong password\"\n              });\n              return;\n            }\n          }\n        }\n\n        // if there is no matched id\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      connnectionData.socket.emit(\"establish session\", {\n        success: false,\n        error: \"id unmatched\"\n      });\n    }\n  }, {\n    key: \"sendUserData\",\n    value: function sendUserData(result, connnectionData) {\n\n      if (result) {\n        connnectionData.socket.emit(\"fetch user\", {\n          success: true,\n          userData: result[0]\n        });\n      } else {\n        connnectionData.socket.emit(\"fetch user\", {\n          success: false,\n          error: \"no data\"\n        });\n      }\n    }\n  }]);\n\n  return UpdateHandler;\n}();\n\nexports.default = UpdateHandler;\n\n//# sourceURL=webpack:///./src/UpdateHandler.js?");

/***/ }),

/***/ "./src/User.js":
/*!*********************!*\
  !*** ./src/User.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar User = function () {\n  function User(id, status, socketId) {\n    _classCallCheck(this, User);\n\n    this.id = id;\n    this.status = status;\n    this.socketId = socketId;\n    this.deckCode = null;\n\n    this.timer = null;\n    this.playingRoomId = null;\n  }\n\n  _createClass(User, [{\n    key: \"setTimer\",\n    value: function setTimer(seconds, callback) {\n\n      this.unsetTimer();\n\n      this.timer = setTimeout(callback, seconds * 1000);\n    }\n  }, {\n    key: \"unsetTimer\",\n    value: function unsetTimer() {\n\n      if (this.timer) {\n        clearTimeout(this.timer);\n      }\n    }\n  }]);\n\n  return User;\n}();\n\nexports.default = User;\n\n\nexports.User = User;\n\n//# sourceURL=webpack:///./src/User.js?");

/***/ }),

/***/ "./src/UserList.js":
/*!*************************!*\
  !*** ./src/UserList.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _User = __webpack_require__(/*! ./User */ \"./src/User.js\");\n\nvar _User2 = _interopRequireDefault(_User);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar UserList = function () {\n  function UserList() {\n    _classCallCheck(this, UserList);\n\n    this.userIdMap = new Map();\n    this.userList = [];\n  }\n\n  _createClass(UserList, [{\n    key: \"register\",\n    value: function register(id, status, socketId) {\n      var user = new _User2.default(id, status, socketId);\n      this.userIdMap.set(user.id, user);\n      this.userList.push(user);\n      return user;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(userId) {\n      var user = this.getById(userId);\n      if (user) {\n        this.userList.splice(this.userList.indexOf(user), 1);\n        this.userIdMap.delete(user.id);\n      }\n    }\n  }, {\n    key: \"exists\",\n    value: function exists(userId) {\n      return this.userIdMap.has(userId);\n    }\n  }, {\n    key: \"getById\",\n    value: function getById(userId) {\n      return this.userIdMap.get(userId);\n    }\n  }, {\n    key: \"getBySocketId\",\n    value: function getBySocketId(socketId) {\n\n      for (var i = 0; i < this.userList.length; i++) {\n        if (this.userList[i].socketId == socketId) {\n          return this.userList[i];\n        }\n      }\n\n      return;\n    }\n  }]);\n\n  return UserList;\n}();\n\nexports.default = UserList;\n\n\nexports.UserList = UserList;\n\n//# sourceURL=webpack:///./src/UserList.js?");

/***/ }),

/***/ "./src/cli-core/Character.js":
/*!***********************************!*\
  !*** ./src/cli-core/Character.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Character = function () {\n  function Character(characterData) {\n    _classCallCheck(this, Character);\n\n    /**\n     * Character meta info\n     */\n    this.meta = characterData;\n\n    /**\n     * Character position\n     */\n    this.coordinate = {\n      x: this.meta.coordinate.x,\n      y: this.meta.coordinate.y\n    }; // in tile grid\n    this.targetPosition = {\n      x: 0,\n      y: 0\n    }; // in real-world graphics\n\n    // Whether this character is frontier of party\n    this._head = false;\n\n    // Current direction\n    this._direction = -1;\n\n    // Character health\n    this._health = this.meta.health;\n  }\n\n  _createClass(Character, [{\n    key: \"speed\",\n    get: function get() {\n      return this.meta.speed;\n    }\n  }, {\n    key: \"health\",\n    get: function get() {\n      return this._health;\n    }\n\n    /**\n     * Set health value\n     */\n    ,\n    set: function set(value) {\n      value = Math.max(Math.min(value, this.meta.maxHealth), 0);\n      if (value != this._health) {\n        this._health = value;\n      }\n    }\n  }, {\n    key: \"jump\",\n    get: function get() {\n      return this._jumpStarted;\n    }\n\n    /**\n     * Start or stop jumping\n     */\n    ,\n    set: function set(value) {\n      if (this._jumpStarted == value) {\n        return;\n      }\n      if (value) {\n        this._jumpStarted = value;\n      }\n    }\n  }, {\n    key: \"head\",\n    get: function get() {\n      return this._head;\n    }\n\n    /**\n     * Set whether is character is head or not\n     */\n    ,\n    set: function set(value) {\n      if (this._head == value) {\n        return;\n      }\n      this._head = value;\n    }\n  }, {\n    key: \"direction\",\n    get: function get() {\n      return this._direction;\n    }\n\n    /**\n     * Set new direction for this character\n     */\n    ,\n    set: function set(value) {\n      if (this._direction == value || value > 3) {\n        return;\n      }\n      this._direction = value;\n    }\n  }]);\n\n  return Character;\n}();\n\nexports.default = Character;\n\n//# sourceURL=webpack:///./src/cli-core/Character.js?");

/***/ }),

/***/ "./src/cli-core/CharacterData.js":
/*!***************************************!*\
  !*** ./src/cli-core/CharacterData.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar CharacterData = function () {\n  function CharacterData(data) {\n    _classCallCheck(this, CharacterData);\n\n    data = data || {};\n    this.index = data.index || 0;\n    this.name = data.name || \"Unnamed\";\n    this.description = data.description || \"\";\n    this.rarity = data.rarity || 0;\n    this.maxHealth = data.maxHealth || 30;\n    this.health = data.health || this.maxHealth;\n    this.speed = data.speed || 3;\n    this.bodyTexture = data.bodyTexture || {\n      front: \"unit-front-no1\",\n      back: \"unit-back-no1\"\n    };\n    this.coordinate = data.coordinate || {\n      x: 0,\n      y: 0\n    };\n  }\n\n  _createClass(CharacterData, [{\n    key: \"equals\",\n    value: function equals(data) {\n      if (data.name == this.name && data.rarity == this.rarity) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }]);\n\n  return CharacterData;\n}();\n\nexports.default = CharacterData;\n\n//# sourceURL=webpack:///./src/cli-core/CharacterData.js?");

/***/ }),

/***/ "./src/cli-core/Configuration.js":
/*!***************************************!*\
  !*** ./src/cli-core/Configuration.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar Configuration = {\n  server: {\n    host: \"localhost:8080\"\n  },\n  baseResolution: {\n    width: 1920,\n    height: 1080\n  },\n  resolution: {\n    width: 1920,\n    height: 1080\n  },\n  resolutionFactor: 1,\n\n  isometric: {\n    unitWidth: 256,\n    unitHeight: 148.616\n  }\n};\n\nexports.default = Configuration;\n\n//# sourceURL=webpack:///./src/cli-core/Configuration.js?");

/***/ }),

/***/ "./src/cli-core/Party.js":
/*!*******************************!*\
  !*** ./src/cli-core/Party.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _nickGenerator = __webpack_require__(/*! nick-generator */ \"nick-generator\");\n\nvar _nickGenerator2 = _interopRequireDefault(_nickGenerator);\n\nvar _Connection = __webpack_require__(/*! ../Connection */ \"./src/Connection.js\");\n\nvar _Connection2 = _interopRequireDefault(_Connection);\n\nvar _Character = __webpack_require__(/*! ./Character.js */ \"./src/cli-core/Character.js\");\n\nvar _Character2 = _interopRequireDefault(_Character);\n\nvar _Configuration = __webpack_require__(/*! ./Configuration.js */ \"./src/cli-core/Configuration.js\");\n\nvar _Configuration2 = _interopRequireDefault(_Configuration);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Party = function () {\n  function Party(userId, id, territoryColor) {\n    var _this = this;\n\n    _classCallCheck(this, Party);\n\n    /**\n     * Party identifier\n     */\n    this.id = id;\n    this.userId = userId ? userId : (0, _nickGenerator2.default)();\n    this.territoryColor = territoryColor;\n    this.isAi = false;\n    this.roomId = null;\n\n    // Start coordinate\n    this._startCoordinate = null;\n    this._startDirection = null;\n\n    /**\n     * Members of party\n     */\n    this.deckCode = null;\n    this.head = null;\n    this.members = [];\n    this._eliminatedMembers = [];\n    this._scheduledCoordinate = {};\n\n    // Party speed\n    this._speed = 0;\n    this._speedOutdated = true;\n\n    // Party direction\n    this._reached = false;\n    this._displaced = false;\n    this._scheduledDirection = -1;\n\n    // Party halt\n    this._halted = false;\n    this._haltTimeLeft = 0;\n    this._haltCallback = null;\n\n    // Path history\n    this._lastStep = null;\n\n    // Event listeners\n    this._onEliminateHandler = [];\n    this._onDamageHandler = [];\n    this._onDisplacedHandler = [];\n\n    // Stop jump when damaged\n    this.onDamage(function () {\n      for (var i in _this.members) {\n        _this.members[i].jump = false;\n      }\n    });\n  }\n\n  _createClass(Party, [{\n    key: \"update\",\n    value: function update(deltaTime) {\n      if (this._displaced) {\n        if (this._halted) {\n          this._haltTimeLeft -= deltaTime;\n          if (this._haltTimeLeft <= 0) {\n            this._halted = false;\n            this._haltCallback();\n          }\n        }\n\n        if (!this._halted) {\n          if (this._isArrived(deltaTime)) {\n            this._finishStep();\n          } else {\n            this._proceedStep(deltaTime);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"onEliminate\",\n    value: function onEliminate(handler) {\n      this._onEliminateHandler.push(handler);\n    }\n  }, {\n    key: \"onDisplaced\",\n    value: function onDisplaced(handler) {\n      this._onDisplacedHandler.push(handler);\n    }\n  }, {\n    key: \"onDamage\",\n    value: function onDamage(handler) {\n      this._onDamageHandler.push(handler);\n    }\n  }, {\n    key: \"setStartCoordinate\",\n    value: function setStartCoordinate(x, y, direction) {\n      this._startCoordinate = {\n        x: x,\n        y: y\n      };\n      this._startDirection = direction;\n    }\n\n    /**\n     * Add new member to party\n     *\n     * @param {Character} member\n     */\n\n  }, {\n    key: \"addMember\",\n    value: function addMember(member) {\n      if (this.members.length < 1) {\n        this.head = member;\n        this.head.head = true;\n      }\n      member.arrowGuideColor = this.territoryColor;\n      this.members.push(member);\n      this._speedOutdated = true;\n    }\n\n    /**\n     * Eliminate member from party\n     *\n     * @param {Character} member\n     */\n\n  }, {\n    key: \"eliminateMember\",\n    value: function eliminateMember(member) {\n      var i = this.members.indexOf(member);\n\n      if (i >= 0) {\n        // Remove from list\n        this.members.splice(i, 1);\n        this._eliminatedMembers.push(member);\n\n        // Disable graphics\n        member.jump = false;\n\n        // If none of members left,\n        if (this.members.length > 0) {\n          // If removed member was head, replace head\n          if (i == 0) {\n            member.head = false;\n            this.members[0].head = true;\n            this.members[0].coordinate = member.coordinate;\n            this.members[0].direction = member.direction;\n            this.head = this.members[0];\n          }\n        }\n        // Dispatch event\n        for (var j = 0; j < this._onEliminateHandler.length; j++) {\n          this._onEliminateHandler[j](member, this.members.length < 1);\n        }\n        this._speedOutdated = true;\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Damage this party!\n     *\n     * @param {Integer} amount\n     */\n\n  }, {\n    key: \"damage\",\n    value: function damage(amount) {\n      if (this.members.length > 0) {\n        this.members[0].health -= amount;\n\n        // Dispatch event\n        for (var j = 0; j < this._onDamageHandler.length; j++) {\n          this._onDamageHandler[j](this.members[0], amount);\n        }\n\n        // Eliminated!\n        if (this.members[0].health <= 0) {\n          this.eliminateMember(this.members[0]);\n          return true;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Heal this party!\n     *\n     * @param {Integer} amount\n     */\n\n  }, {\n    key: \"heal\",\n    value: function heal(amount) {\n      if (this.members.length > 0) {\n        for (var i = 0; i < this.members.length; i++) {\n          if (this.members[i].health < this.members[i].meta.maxHealth) {\n            this.members[i].health += amount;\n            break;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"displaceToStartCoordinate\",\n    value: function displaceToStartCoordinate() {\n      this.displace(this._startCoordinate, this._startDirection);\n    }\n  }, {\n    key: \"displace\",\n    value: function displace(coordinate, direction) {\n      // Initialize\n      this._displaced = true;\n      this._justDisplaced = true;\n      this._scheduledDirection = -1;\n\n      var position = this._translateCoordinate(coordinate);\n      this.head.direction = direction;\n      this.head.coordinate.x = coordinate.x;\n      this.head.coordinate.y = coordinate.y;\n      this.head.targetPosition.x = position.x;\n      this.head.targetPosition.y = position.y;\n      this.head.x = position.x;\n      this.head.y = position.y;\n      this._scheduledCoordinate.x = coordinate.x;\n      this._scheduledCoordinate.y = coordinate.y;\n\n      this.head.jump = true;\n\n      for (var i = 1; i < this.members.length; i++) {\n        this.members[i].jump = false;\n      }\n      this._lastStep = null;\n\n      for (var _i = 0; _i < this._onDisplacedHandler.length; _i++) {\n        this._onDisplacedHandler[_i](coordinate);\n      }\n    }\n  }, {\n    key: \"halt\",\n    value: function halt(seconds, callback) {\n      this._halted = true;\n      this._haltTimeLeft = seconds * 60;\n      this._haltCallback = callback;\n    }\n  }, {\n    key: \"scheduleDirection\",\n    value: function scheduleDirection(direction, coordinate) {\n      if (!this._halted) {\n        this._scheduledDirection = direction;\n        if (coordinate) {\n\n          this._scheduledCoordinate.x = coordinate.x;\n          this._scheduledCoordinate.y = coordinate.y;\n        } else {\n\n          this._scheduledCoordinate.x = this.head.coordinate.x;\n          this._scheduledCoordinate.y = this.head.coordinate.y;\n\n          _Connection2.default.rooms.getById(this.roomId).broadcast(\"change direction\", {\n            pratyId: this.id,\n            direction: this._scheduledDirection,\n            coordinate: this._scheduledCoordinate\n          }, this.userId);\n        }\n      }\n    }\n  }, {\n    key: \"nextStep\",\n    value: function nextStep() {\n      this._reached = false;\n      if (this._hasScheduledDirection()) {\n        this._changeDirection();\n      }\n      this._targetForward(this.head);\n    }\n  }, {\n    key: \"_isArrived\",\n    value: function _isArrived(deltaTime) {\n      var destX = this.head.coordinate.x * _Configuration2.default.isometric.unitWidth / 2 - this.head.coordinate.y * _Configuration2.default.isometric.unitWidth / 2;\n\n      var charX = this.head.x;\n      var distanceLeft = this.head.direction < 2 ? destX - charX : charX - destX;\n\n      return Math.abs(this._getVelocity(deltaTime).x) >= distanceLeft;\n    }\n  }, {\n    key: \"_finishStep\",\n    value: function _finishStep() {\n      // Ignore function call when head coordinate did not changed\n      if (this._lastStep != null && this._lastStep.x == this.head.coordinate.x && this._lastStep.y == this.head.coordinate.y) {\n        return;\n      }\n\n      if (this._scheduledCoordinate.x != this.head.coordinate.x || this._scheduledCoordinate.y != this.head.coordinate.y) {\n        this.displace(this._scheduledCoordinate, this._scheduledDirection);\n        return;\n      }\n\n      this._lastStep = this._clone(this.head.coordinate);\n\n      var position = void 0;\n      for (var i = this.members.length - 1; i >= 0; i--) {\n        var member = this.members[i];\n        if (i > 0) {\n          position = this.members[i - 1].targetPosition;\n          if (this.members[i - 1].jump) {\n            if (!member.jump && !this._justDisplaced) {\n              member.jump = true;\n            }\n            member.direction = this.members[i - 1].direction;\n            member.coordinate = this._clone(this.members[i - 1].coordinate);\n          }\n        } else {\n          position = this._translateCoordinate(this.head.coordinate);\n        }\n        if (member.jump) {\n          member.targetPosition.x = position.x;\n          member.targetPosition.y = position.y;\n          member.x = member.targetPosition.x;\n          member.y = member.targetPosition.y;\n        }\n      }\n\n      this._reached = true;\n      this._justDisplaced = false;\n    }\n  }, {\n    key: \"_proceedStep\",\n    value: function _proceedStep(deltaTime) {\n      for (var i = this.members.length - 1; i >= 0; i--) {\n        var member = this.members[i];\n        if (!member.jump) {\n          continue;\n        }\n        var velocity = this._getVelocity(deltaTime, member.direction);\n        member.x += velocity.x;\n        member.y += velocity.y;\n      }\n    }\n  }, {\n    key: \"_targetForward\",\n    value: function _targetForward(member) {\n      switch (member.direction) {\n        case 0:\n          member.coordinate.x++;\n          break;\n        case 1:\n          member.coordinate.y--;\n          break;\n        case 2:\n          member.coordinate.x--;\n          break;\n        case 3:\n          member.coordinate.y++;\n          break;\n      }\n      this._scheduledCoordinate.x = member.coordinate.x;\n      this._scheduledCoordinate.y = member.coordinate.y;\n    }\n  }, {\n    key: \"_hasScheduledDirection\",\n    value: function _hasScheduledDirection() {\n      return this._scheduledDirection >= 0;\n    }\n  }, {\n    key: \"_changeDirection\",\n    value: function _changeDirection() {\n      if (this._scheduledDirection >= 0) {\n        this.head.direction = this._scheduledDirection;\n        this._scheduledDirection = -1;\n      }\n    }\n  }, {\n    key: \"_getVelocity\",\n    value: function _getVelocity(deltaTime) {\n      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n\n      var velocityX = this.speed * deltaTime;\n      var velocityY = this.speed / 1.722 * deltaTime;\n\n      if (direction < 0) {\n        direction = this.head.direction;\n      }\n\n      if (direction > 1) {\n        velocityX = -velocityX;\n      }\n\n      if (direction > 0 && direction < 3) {\n        velocityY = -velocityY;\n      }\n\n      return {\n        x: velocityX,\n        y: velocityY\n      };\n    }\n  }, {\n    key: \"_translateCoordinate\",\n    value: function _translateCoordinate(coordinate) {\n      var tx = coordinate.x * _Configuration2.default.isometric.unitWidth / 2 - coordinate.y * _Configuration2.default.isometric.unitWidth / 2;\n      var ty = coordinate.x * _Configuration2.default.isometric.unitHeight / 2 + coordinate.y * _Configuration2.default.isometric.unitHeight / 2;\n\n      return {\n        x: tx,\n        y: ty\n      };\n    }\n  }, {\n    key: \"_clone\",\n    value: function _clone(obj) {\n      var newObj = {};\n      var keys = Object.keys(obj);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = keys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var key = _step.value;\n\n          newObj[key] = obj[key];\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return newObj;\n    }\n  }, {\n    key: \"reached\",\n    get: function get() {\n      return this._reached && !this._halted;\n    }\n  }, {\n    key: \"halted\",\n    get: function get() {\n      return this._halted;\n    }\n  }, {\n    key: \"startCoordinate\",\n    get: function get() {\n      return this._startCoordinate || {\n        x: 0,\n        y: 0\n      };\n    }\n\n    /**\n     * Get direction of this party\n     */\n\n  }, {\n    key: \"direction\",\n    get: function get() {\n      return this.head.direction;\n    }\n\n    /**\n     * Get speed of this party\n     */\n\n  }, {\n    key: \"speed\",\n    get: function get() {\n      if (this.members.length < 1) {\n        return 0;\n      }\n      if (this._speedOutdated) {\n        var minimumSpeed = this.members[0].meta.speed;\n        for (var i = 1; i < this.members.length; i++) {\n          if (this.members[i].meta.speed < minimumSpeed) {\n            minimumSpeed = this.members[i].meta.speed;\n          }\n        }\n        this._speed = minimumSpeed;\n        this._speedOutdated = false;\n      }\n      return this._speed;\n    }\n  }, {\n    key: \"scheduledDirection\",\n    get: function get() {\n      return this._scheduledDirection;\n    }\n  }, {\n    key: \"nextDirection\",\n    get: function get() {\n      return this._scheduledDirection >= 0 ? this._scheduledDirection : this.direction;\n    }\n  }]);\n\n  return Party;\n}();\n\nexports.default = Party;\n\n//# sourceURL=webpack:///./src/cli-core/Party.js?");

/***/ }),

/***/ "./src/cli-core/PartySimulator.js":
/*!****************************************!*\
  !*** ./src/cli-core/PartySimulator.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _easystarjs = __webpack_require__(/*! easystarjs */ \"easystarjs\");\n\nvar _easystarjs2 = _interopRequireDefault(_easystarjs);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar PartySimulator = function () {\n  function PartySimulator(party, territory, obstacles) {\n    var _this = this;\n\n    _classCallCheck(this, PartySimulator);\n\n    // Basic data to evaluate\n    this._party = party;\n    this._territory = null;\n    this._obstacles = null;\n\n    // Change party status to AI\n    this._party.isAi = true;\n\n    // Pathfinder\n    this._pathfinder = null;\n    this._findLimit = 4;\n\n    // Current status\n    this._plannedPath = [];\n    this._plannedPathIndex = 0;\n\n    this._onActionHandlers = [];\n\n    this._party.onEliminate(function (member, deadly) {\n      if (deadly) {\n        _this._pathfinder = null;\n      }\n      _this.clear();\n    });\n\n    this._party.onDisplaced(function (coordinate) {\n      _this.clear();\n    });\n  }\n\n  _createClass(PartySimulator, [{\n    key: \"setEnvironment\",\n    value: function setEnvironment(territory, obstacles) {\n      var _this2 = this;\n\n      this._territory = territory;\n      this._obstacles = obstacles;\n      this._initializePathfinder();\n\n      this._territory.onOccupy(function (party, changes) {\n        if (party == _this2._party.id) {\n          _this2.clear();\n        }\n      });\n    }\n  }, {\n    key: \"onAction\",\n    value: function onAction(handler) {\n      this._onActionHandlers.push(handler);\n    }\n  }, {\n    key: \"update\",\n    value: function update(deltaTime) {\n      if (this._pathfinder == null) {\n        return;\n      }\n\n      if (this._plannedPathIndex >= this._plannedPath.length) {\n        if (Math.random() > 0.5) {\n          this._findLimit = 4;\n        }\n        this._planPath(0, this._findLimit);\n      }\n\n      // 길대로 따라가자\n\n      if (this._party._isArrived(deltaTime)) {\n        var pcoord = this._party.head.coordinate;\n\n        var curr = pcoord;\n        var next = this._plannedPath[this._plannedPathIndex];\n\n        var ndir = 0;\n\n        if (next.x > curr.x) {\n          ndir = 0;\n        } else if (next.x < curr.x) {\n          ndir = 2;\n        } else if (next.y > curr.y) {\n          ndir = 3;\n        } else {\n          ndir = 1;\n        }\n\n        // 방향전환이 있으면,\n        if (ndir != this._party.direction) {\n          for (var i = 0; i < this._onActionHandlers.length; i++) {\n            // setTimeout(() => {\n            this._onActionHandlers[i](ndir, next);\n            //}, 300 * Math.random());\n          }\n        }\n        this._plannedPathIndex++;\n      }\n    }\n  }, {\n    key: \"_planPath\",\n    value: function _planPath(startLimit, endLimit) {\n      var _this3 = this;\n\n      var currentStep = this._party.head.coordinate;\n\n      var preferredSteps = [];\n\n      // treaverse near area\n      var esx = Math.max(0, currentStep.x - endLimit);\n      var eex = Math.min(this._territory.width - 1, currentStep.x + endLimit);\n      var esy = Math.max(0, currentStep.y - endLimit);\n      var eey = Math.min(this._territory.height - 1, currentStep.y + endLimit);\n\n      var ssx = Math.max(0, currentStep.x - startLimit);\n      var sex = Math.min(this._territory.width - 1, currentStep.x + startLimit);\n      var ssy = Math.max(0, currentStep.y - startLimit);\n      var sey = Math.min(this._territory.height - 1, currentStep.y + startLimit);\n\n      for (var y = esy; y <= eey; y++) {\n        if (y == currentStep.y) {\n          continue;\n        }\n\n        for (var x = esx; x <= eex; x++) {\n          if (x == currentStep.x) {\n            continue;\n          }\n\n          // Too close\n          if (x >= ssx && x <= sex && y >= ssy && y <= sey) {\n            continue;\n          }\n          //console.log(x, y)\n          // Is occupiable\n          if (this._isOccupiable(x, y) && this._isOccupiable(currentStep.x, y) && this._isOccupiable(x, currentStep.y)) {\n            preferredSteps.push({ x: x, y: y });\n          }\n        }\n      }\n\n      // If not found, increase traverse area\n      if (preferredSteps.length < 1) {\n        if (endLimit >= this._territory.width || endLimit >= this._territory.height) {\n          preferredSteps.push({\n            x: Math.floor((this._territory.width - 1) * Math.random()),\n            y: Math.floor((this._territory.height - 1) * Math.random())\n          });\n        } else {\n          this._findLimit *= 2;\n          this._planPath(endLimit, this._findLimit);\n          return;\n        }\n      }\n      //console.log(preferredSteps)\n      // Random select from the possible steps\n      var selectedStep = preferredSteps[Math.floor((preferredSteps.length - 1) * Math.random())];\n      // Target coordinates\n      var tcoord = [];\n      tcoord.push({\n        x: currentStep.x,\n        y: currentStep.y\n      });\n      tcoord.push({\n        x: selectedStep.x,\n        y: currentStep.y\n      });\n      tcoord.push({\n        x: selectedStep.x,\n        y: selectedStep.y\n      });\n      tcoord.push({\n        x: currentStep.x,\n        y: selectedStep.y\n      });\n      tcoord.push({\n        x: currentStep.x,\n        y: currentStep.y\n      });\n\n      if (Math.random() > 0.5) {\n        var temp = tcoord[1];\n        tcoord[1] = tcoord[3];\n        tcoord[3] = temp;\n      }\n\n      // Interpolate!\n      for (var i = 0; i < tcoord.length - 1; i++) {\n        this._pathfinder.findPath(tcoord[i].x, tcoord[i].y, tcoord[i + 1].x, tcoord[i + 1].y, function (pathFound) {\n          if (pathFound != null && pathFound.length > 0) {\n            _this3._plannedPath = _this3._plannedPath.concat(pathFound.slice(1));\n          }\n        });\n        this._pathfinder.calculate();\n      }\n\n      // REMOVE TAILING\n      var cleaned = [];\n      cleaned.push(this._plannedPath[0]);\n      for (var _i = 1; _i < this._plannedPath.length - 1; _i++) {\n        var prv = this._plannedPath[_i - 1];\n        var now = this._plannedPath[_i];\n        var nex = this._plannedPath[_i + 1];\n\n        if (prv.x == nex.x && prv.y == nex.y) {\n          _i += 2;\n          continue;\n        } else {\n          cleaned.push(now);\n          if (_i == this._plannedPath.length - 2) {\n            cleaned.push(nex);\n          }\n        }\n      }\n      this._plannedPath = cleaned;\n\n      this._plannedPathIndex = 0;\n    }\n  }, {\n    key: \"_isOccupiable\",\n    value: function _isOccupiable(x, y) {\n      var territory = this._territory.get(x, y);\n      if (territory.owner != this._party.id) {\n        if (this._obstacles[y][x] == 0) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"_initializePathfinder\",\n    value: function _initializePathfinder() {\n      this._pathfinder = new _easystarjs2.default.js();\n      this._pathfinder.enableSync();\n      this._pathfinder.setGrid(this._obstacles);\n      this._pathfinder.setAcceptableTiles([0]);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._plannedPath = [];\n    }\n  }]);\n\n  return PartySimulator;\n}();\n\nexports.default = PartySimulator;\n\n//# sourceURL=webpack:///./src/cli-core/PartySimulator.js?");

/***/ }),

/***/ "./src/cli-core/Pathfinder.js":
/*!************************************!*\
  !*** ./src/cli-core/Pathfinder.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Pathfinder = function () {\n  function Pathfinder() {\n    _classCallCheck(this, Pathfinder);\n\n    // Grid instances\n    this._grid = null;\n    this._edgeGrid = null;\n    this._gridWidth = 0;\n    this._gridHeight = 0;\n    this._gridSize = 0;\n\n    this._context = 0;\n  }\n\n  _createClass(Pathfinder, [{\n    key: \"setGrid\",\n    value: function setGrid(grid, edgeGrid) {\n      this._grid = grid;\n      this._edgeGrid = edgeGrid;\n      this._gridWidth = grid[0].length;\n      this._gridHeight = grid.length;\n      this._gridSize = this._gridWidth * this._gridHeight;\n    }\n  }, {\n    key: \"findPath\",\n    value: function findPath(partyId, start, end) {\n      var forbiddenMove = 0;\n      if (start.x > end.x) forbiddenMove = 0;else if (start.x < end.x) forbiddenMove = 1;else if (start.y > end.y) forbiddenMove = 2;else forbiddenMove = 3;\n\n      this._context = {\n        party: partyId,\n        start: start,\n        end: end,\n        forbiddenMove: forbiddenMove\n      };\n\n      var pathStart = new PathfinderNode(null, start.x, start.y, this._gridWidth);\n      var pathEnd = new PathfinderNode(null, end.x, end.y, this._gridWidth);\n      var visited = new Array(this._gridSize);\n\n      var open = [pathStart];\n      var closed = [];\n      var result = [];\n      var step = void 0;\n      var length = void 0,\n          max = void 0,\n          min = void 0,\n          i = void 0,\n          j = void 0;\n\n      while (length = open.length) {\n        max = this._gridSize;\n        min = -1;\n        for (i = 0; i < length; i++) {\n          if (open[i].f < max) {\n            max = open[i].f;\n            min = i;\n          }\n        }\n        var node = open.splice(min, 1)[0];\n        if (node.value === pathEnd.value) {\n          step = closed[closed.push(node) - 1];\n          do {\n            result.push({ x: step.x, y: step.y });\n          } while (step = step.parent);\n          visited = closed = open = [];\n          result.reverse();\n        } else {\n          var neighbours = this._neighbors(node.x, node.y);\n          for (i = 0, j = neighbours.length; i < j; i++) {\n            step = new PathfinderNode(node, neighbours[i].x, neighbours[i].y, this._gridWidth);\n            if (!visited[step.value]) {\n              step.g = node.g + this._distance(neighbours[i], node);\n              step.f = step.g + this._distance(neighbours[i], pathEnd);\n              open.push(step);\n              visited[step.value] = true;\n            }\n          }\n          closed.push(node);\n        }\n      }\n      return result;\n    }\n  }, {\n    key: \"_distance\",\n    value: function _distance(point, goal) {\n      return Math.abs(point.x - goal.x) + Math.abs(point.y - goal.y);\n    }\n  }, {\n    key: \"_neighbors\",\n    value: function _neighbors(x, y) {\n      var approachable = [true, true, true, true];\n      if (this._context.start.x == x && this._context.start.y == y) {\n        approachable[this._context.forbiddenMove] = false;\n      }\n      if (this._grid[y][x].lineOwner == this._context.party) {\n        switch (this._grid[y][x].lineCode) {\n          case 1:\n            // north and south\n            approachable[0] = false;\n            approachable[1] = false;\n            break;\n          case 2:\n            // west and east\n            approachable[2] = false;\n            approachable[3] = false;\n            break;\n          case 3:\n            // north and west\n            approachable[1] = false;\n            approachable[3] = false;\n            break;\n          case 4:\n            // north and east\n            approachable[0] = false;\n            approachable[3] = false;\n            break;\n          case 5:\n            // south and east\n            approachable[0] = false;\n            approachable[2] = false;\n            break;\n          case 6:\n            // south and west\n            approachable[1] = false;\n            approachable[2] = false;\n            break;\n        }\n      }\n\n      var N = y - 1,\n          S = y + 1,\n          E = x + 1,\n          W = x - 1,\n          myN = N > -1 && this._steppable(x, N) && approachable[2],\n          myS = S < this._gridHeight && this._steppable(x, S) && approachable[3],\n          myE = E < this._gridWidth && this._steppable(E, y) && approachable[1],\n          myW = W > -1 && this._steppable(W, y) && approachable[0],\n          result = [];\n      if (myN) result.push({ x: x, y: N });\n      if (myE) result.push({ x: E, y: y });\n      if (myS) result.push({ x: x, y: S });\n      if (myW) result.push({ x: W, y: y });\n      return result;\n    }\n  }, {\n    key: \"_steppable\",\n    value: function _steppable(x, y) {\n      return this._grid[y][x].lineOwner == this._context.party || this._edgeGrid[y][x] == this._context.party;\n    }\n  }]);\n\n  return Pathfinder;\n}();\n\nexports.default = Pathfinder;\n\nvar PathfinderNode = function PathfinderNode(parent, x, y, width) {\n  _classCallCheck(this, PathfinderNode);\n\n  this.parent = parent;\n  this.x = x;\n  this.y = y;\n  this.f = 0;\n  this.g = 0;\n  this.value = y * width + x;\n};\n\n//# sourceURL=webpack:///./src/cli-core/Pathfinder.js?");

/***/ }),

/***/ "./src/cli-core/Stage.js":
/*!*******************************!*\
  !*** ./src/cli-core/Stage.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _StageData = __webpack_require__(/*! ./StageData.js */ \"./src/cli-core/StageData.js\");\n\nvar _StageData2 = _interopRequireDefault(_StageData);\n\nvar _StageTerritory = __webpack_require__(/*! ./StageTerritory.js */ \"./src/cli-core/StageTerritory.js\");\n\nvar _StageTerritory2 = _interopRequireDefault(_StageTerritory);\n\nvar _Configuration = __webpack_require__(/*! ./Configuration.js */ \"./src/cli-core/Configuration.js\");\n\nvar _Configuration2 = _interopRequireDefault(_Configuration);\n\nvar _StageTimer = __webpack_require__(/*! ./StageTimer.js */ \"./src/cli-core/StageTimer.js\");\n\nvar _StageTimer2 = _interopRequireDefault(_StageTimer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Stage = function () {\n  function Stage(stageData) {\n    _classCallCheck(this, Stage);\n\n    /**\n     * Metadata for stage\n     */\n    this.meta = stageData;\n    this.roomId = null;\n\n    // Parties in this stage\n    this._parties = [];\n\n    // Territory\n    this._territory = null;\n\n    // Timer\n    this._timer = null;\n\n    this._initializeTerritory();\n    this._createTimer(120);\n  }\n\n  _createClass(Stage, [{\n    key: \"update\",\n\n\n    /**\n     * Make real-time updates in stage\n     */\n    value: function update(deltaTime) {\n      // Update parties\n      for (var i = 0; i < this._parties.length; i++) {\n        var party = this._parties[i];\n\n        party.update(deltaTime);\n\n        // If party reached next tile,\n        if (party.reached) {\n          // Evaluate hit boundary\n          var hitBoundary = this._getHitBoundary(party.head.coordinate);\n\n          //If it hit obstacle or out of bound,\n          if (hitBoundary.indexOf(party.nextDirection) >= 0) {\n            this._territory.removeLine(party.id);\n            this.damageParty(party, 10);\n          }\n\n          // Let's roll'in\n          else {\n              var nextDirection = party.scheduledDirection < 0 ? party.direction : party.scheduledDirection;\n              this._territory.step(party.id, party.head.coordinate, party.direction, nextDirection);\n              // Go next!\n              party.nextStep();\n            }\n        }\n      }\n\n      // Update timer\n      this._timer.update(deltaTime);\n    }\n  }, {\n    key: \"damageParty\",\n    value: function damageParty(party, damage) {\n      party.damage(damage);\n      party.halt(0.4, function () {\n        party.displaceToStartCoordinate();\n      });\n    }\n\n    /**\n     * Add new party to stage\n     */\n\n  }, {\n    key: \"addParty\",\n    value: function addParty(party) {\n      this._parties.push(party);\n    }\n\n    /**\n     * Territory data\n     */\n\n  }, {\n    key: \"_initializeTerritory\",\n    value: function _initializeTerritory() {\n      var _this = this;\n\n      this._territory = new _StageTerritory2.default(this.meta.dimension.width, this.meta.dimension.height);\n      for (var y = 0; y < this._territory.height; y++) {\n        for (var x = 0; x < this._territory.width; x++) {\n          if (this.meta.territory[y][x] > 0) {\n            this._territory.occupy(this.meta.territory[y][x], { x: x, y: y });\n          }\n        }\n      }\n\n      this._territory.onHitLine(function (partyId, hitPartyId) {\n        _this._onPartyHitLine(partyId, hitPartyId);\n      });\n\n      this._territory.onOccupy(function (partyId, changes) {\n        _this._onPartyOccupy(partyId, changes);\n      });\n    }\n  }, {\n    key: \"_createTimer\",\n    value: function _createTimer(seconds) {\n      this._timer = new _StageTimer2.default(seconds);\n    }\n  }, {\n    key: \"_getHitBoundary\",\n    value: function _getHitBoundary(coordinate) {\n      if (coordinate.y < 0 || coordinate.y >= this.meta.terrain.length) {\n        return [0, 1, 2, 3];\n      }\n      if (coordinate.x < 0 || coordinate.x >= this.meta.terrain[coordinate.y].length) {\n        return [0, 1, 2, 3];\n      }\n\n      var boundary = [];\n\n      if (coordinate.y == 0) boundary.push(1);\n      if (coordinate.x == 0) boundary.push(2);\n      if (coordinate.y == this.meta.dimension.height - 1) boundary.push(3);\n      if (coordinate.x == this.meta.dimension.width - 1) boundary.push(0);\n\n      // TODO: check whether it is an obstacle\n      if (this.meta.obstacles[coordinate.y][coordinate.x] > 0) {\n        return [0, 1, 2, 3];\n      }\n\n      return boundary;\n    }\n  }, {\n    key: \"_onPartyHitLine\",\n    value: function _onPartyHitLine(subjectId, objectId) {\n      var subjectParty = void 0;\n      var objectParty = void 0;\n      // Find party\n      for (var i = 0; i < this._parties.length; i++) {\n        if (this._parties[i].id == subjectId) {\n          subjectParty = this._parties[i];\n        }\n        if (this._parties[i].id == objectId) {\n          objectParty = this._parties[i];\n        }\n      }\n\n      // If it hit it's line\n      this.damageParty(objectParty, 10);\n    }\n  }, {\n    key: \"_onPartyOccupy\",\n    value: function _onPartyOccupy(partyId, changes) {\n      // 만약 적이 먹은 영역에 내가 있다면, die!\n    }\n  }, {\n    key: \"parties\",\n    get: function get() {\n      return this._parties;\n    }\n  }, {\n    key: \"timer\",\n    get: function get() {\n      return this._timer;\n    }\n  }, {\n    key: \"territory\",\n    get: function get() {\n      return this._territory;\n    }\n  }]);\n\n  return Stage;\n}();\n\nexports.default = Stage;\n\n//# sourceURL=webpack:///./src/cli-core/Stage.js?");

/***/ }),

/***/ "./src/cli-core/StageData.js":
/*!***********************************!*\
  !*** ./src/cli-core/StageData.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar gen = __webpack_require__(/*! random-seed */ \"random-seed\");\n\nvar StageData = function () {\n  function StageData(seed) {\n    _classCallCheck(this, StageData);\n\n    this.dimension = {\n      width: 16,\n      height: 16\n    };\n    this.seed = seed;\n    this.random = gen(this.seed);\n    this.territory = this._generateEmptyTerritory();\n    this.terrain = this._generateTerrain();\n    this.obstacles = this._generateObstacles();\n  }\n\n  _createClass(StageData, [{\n    key: \"_generateEmptyTerritory\",\n    value: function _generateEmptyTerritory() {\n      var territory = [];\n      for (var y = 0; y < this.dimension.height; y++) {\n        territory[y] = [];\n        for (var x = 0; x < this.dimension.width; x++) {\n          if (y < 3 && x < 3) {\n            territory[y][x] = 2;\n          } else if (y < 3 && x > this.dimension.width - 4) {\n            territory[y][x] = 1;\n          } else if (y > this.dimension.height - 4 && x > this.dimension.width - 4) {\n            territory[y][x] = 4;\n          } else if (y > this.dimension.height - 4 && x < 3) {\n            territory[y][x] = 3;\n          } else {\n            territory[y][x] = 0;\n          }\n        }\n      }\n      return territory;\n    }\n  }, {\n    key: \"_generateTerrain\",\n    value: function _generateTerrain() {\n      var terrain = [];\n      for (var y = 0; y < this.dimension.height; y++) {\n        terrain[y] = [];\n        for (var x = 0; x < this.dimension.width; x++) {\n          if (this.territory[y][x] > 0) {\n            terrain[y][x] = 0;\n            continue;\n          }\n          terrain[y][x] = this.random(100) > 90 ? -1 : this.random(100) > 30 ? 0 : 1;\n        }\n      }\n      return terrain;\n    }\n  }, {\n    key: \"_generateObstacles\",\n    value: function _generateObstacles(seed) {\n      var obstacles = [];\n      for (var y = 0; y < this.dimension.height; y++) {\n        obstacles[y] = [];\n        for (var x = 0; x < this.dimension.width; x++) {\n          if (this.territory[y][x] || this.terrain[y][x] == -1) {\n            obstacles[y][x] = 0;\n            continue;\n          }\n          obstacles[y][x] = this.random(100) > 95 ? Math.floor(this.random(100) * 0.1) : 0;\n        }\n      }\n      return obstacles;\n    }\n  }]);\n\n  return StageData;\n}();\n\nexports.default = StageData;\n\n//# sourceURL=webpack:///./src/cli-core/StageData.js?");

/***/ }),

/***/ "./src/cli-core/StageTerritory.js":
/*!****************************************!*\
  !*** ./src/cli-core/StageTerritory.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Pathfinder = __webpack_require__(/*! ./Pathfinder */ \"./src/cli-core/Pathfinder.js\");\n\nvar _Pathfinder2 = _interopRequireDefault(_Pathfinder);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar StageTerritory = function () {\n  function StageTerritory(width, height) {\n    _classCallCheck(this, StageTerritory);\n\n    // Territory size\n    this._width = width;\n    this._height = height;\n\n    // Ownership data\n    this._grid = null;\n    this._edgeGrid = null;\n\n    // Pathfinder\n    this._pathfinder = null;\n\n    // Event handlers\n    this._onHitLineHandler = [];\n    this._onOccupyHandler = [];\n\n    this._initialize();\n  }\n\n  _createClass(StageTerritory, [{\n    key: \"onHitLine\",\n    value: function onHitLine(handler) {\n      this._onHitLineHandler.push(handler);\n    }\n  }, {\n    key: \"onOccupy\",\n    value: function onOccupy(handler) {\n      this._onOccupyHandler.push(handler);\n    }\n  }, {\n    key: \"get\",\n    value: function get(x, y) {\n      return this._grid[y][x];\n    }\n  }, {\n    key: \"occupy\",\n    value: function occupy(partyId, coordinate) {\n      var changes = [];\n      var tile = this._grid[coordinate.y][coordinate.x];\n      if (tile.owner != partyId) {\n        tile.owner = partyId;\n        changes.push(tile);\n      }\n\n      // 인접한 타일이 다른 타일이면\n      this._updateEdges(coordinate.x - 1, coordinate.y - 1, coordinate.x + 1, coordinate.y + 1);\n\n      return changes;\n    }\n  }, {\n    key: \"view\",\n    value: function view() {\n      for (var y = 0; y < this._height; y++) {\n        var ss = \"(\" + y + \")  \";\n        for (var x = 0; x < this._width; x++) {\n          var tile = this._grid[y][x];\n          ss += tile.owner + (tile.lineOwner > 0 ? \"|\" + tile.lineOwner + \"|\" : \"\") + \"   \";\n        }\n        console.log(ss);\n      }\n      console.log(\"\");\n    }\n  }, {\n    key: \"step\",\n    value: function step(partyId, coordinate, direction, nextDirection) {\n      var changes = [];\n      var tile = this._grid[coordinate.y][coordinate.x];\n\n      // 만약 내 영역이면서, 가장자리이면\n      if (tile.owner == partyId && this._edgeGrid[tile.y][tile.x] == partyId) {\n        // 밖에서 안으로 들어오는거면\n        var adjacentLinedTiles = this._adjacentLinedTiles(tile, false);\n\n        if (adjacentLinedTiles.length > 0) {\n          // 폐곡면이라면\n          var closedLoop = this._pathfinder.findPath(partyId, adjacentLinedTiles[0], tile);\n          if (closedLoop.length > 0) {\n            changes = changes.concat(this._fillArea(partyId, closedLoop));\n          }\n        }\n      }\n\n      ///////// 다른 사람 영역 전체 먹었을때도 포함\n\n      // 다른 선을 밟는다면\n      if (tile.lineOwner > 0) {\n        var lineOwner = tile.lineOwner;\n\n        changes = changes.concat(this.removeLine(tile.lineOwner));\n        // Dispatch!\n        for (var i = 0; i < this._onHitLineHandler.length; i++) {\n          this._onHitLineHandler[i](partyId, lineOwner);\n        }\n        if (lineOwner == partyId) {\n          return changes;\n        }\n      }\n\n      // 만약 다른 사람 땅이거나, 점령되지 않은 지역이라면\n      if (tile.owner != partyId) {\n        tile.lineOwner = partyId;\n        tile.lineCode = this._getLineSubcode(direction, nextDirection);\n        changes.push(tile);\n      }\n\n      return changes;\n    }\n  }, {\n    key: \"_initialize\",\n    value: function _initialize() {\n      this._grid = [];\n      this._edgeGrid = [];\n      for (var y = 0; y < this._height; y++) {\n        this._grid[y] = [];\n        this._edgeGrid[y] = [];\n        for (var x = 0; x < this._width; x++) {\n          this._grid[y][x] = new TerritoryTile(x, y);\n          this._edgeGrid[y][x] = 0;\n        }\n      }\n      this._pathfinder = new _Pathfinder2.default();\n      this._pathfinder.setGrid(this._grid, this._edgeGrid);\n    }\n  }, {\n    key: \"removeLine\",\n    value: function removeLine(partyId) {\n      for (var y = 0; y < this._height; y++) {\n        for (var x = 0; x < this._width; x++) {\n          var tile = this._grid[y][x];\n          if (tile.lineOwner == partyId) {\n            tile.lineOwner = 0;\n            tile.lineCode = 0;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_fillArea\",\n    value: function _fillArea(partyId, path) {\n      var lineHitParties = [];\n      var fillArea = [];\n      var fillAreaWidth = 0;\n      var fillAreaHeight = 0;\n      var fillAreaOffsetX = path[0].x;\n      var fillAreaOffsetY = path[0].y;\n\n      // Determine offset, Update opponent's edge\n      for (var i = 0; i < path.length; i++) {\n        fillAreaWidth = Math.max(path[i].x + 1, fillAreaWidth);\n        fillAreaHeight = Math.max(path[i].y + 1, fillAreaHeight);\n        fillAreaOffsetX = Math.min(path[i].x, fillAreaOffsetX);\n        fillAreaOffsetY = Math.min(path[i].y, fillAreaOffsetY);\n      }\n      fillAreaWidth -= fillAreaOffsetX;\n      fillAreaHeight -= fillAreaOffsetY;\n\n      // Initialize fillarea\n      for (var y = 0; y < fillAreaHeight * 3; y++) {\n        fillArea[y] = [];\n        for (var x = 0; x < fillAreaWidth * 3; x++) {\n          fillArea[y][x] = 0;\n        }\n      }\n\n      // Create specified space, Update path edge\n      for (var _i = 0; _i < path.length; _i++) {\n        var ppath = _i == 0 ? path[path.length - 1] : path[_i - 1];\n        var cpath = path[_i];\n        var npath = _i == path.length - 1 ? path[0] : path[_i + 1];\n\n        var px = (cpath.x - fillAreaOffsetX) * 3;\n        var py = (cpath.y - fillAreaOffsetY) * 3;\n\n        var dpx = cpath.x - ppath.x;\n        var dpy = cpath.y - ppath.y;\n        var dnx = cpath.x - npath.x;\n        var dny = cpath.y - npath.y;\n\n        if (dpx != 0) {\n          fillArea[py + 1][px + (dpx > 0 ? 0 : 2)] = 1;\n        } else {\n          fillArea[py + (dpy > 0 ? 0 : 2)][px + 1] = 1;\n        }\n        if (dnx != 0) {\n          fillArea[py + 1][px + (dnx > 0 ? 0 : 2)] = 1;\n        } else {\n          fillArea[py + (dny > 0 ? 0 : 2)][px + 1] = 1;\n        }\n\n        fillArea[py + 1][px + 1] = 1;\n      }\n\n      // Pick flood point\n      var floodFillSeed = { x: 0, y: 0 };\n      for (var _x = 0; _x < fillAreaWidth; _x++) {\n        if (fillArea[1][_x * 3 + 1] > 0) {\n          floodFillSeed.x = _x * 3 + 2;\n          floodFillSeed.y = 2;\n          break;\n        }\n      }\n      // Flood fill\n      var queueX = [floodFillSeed.x];\n      var queueY = [floodFillSeed.y];\n      while (queueY.length) {\n        var currentX = queueX.pop();\n        var currentY = queueY.pop();\n        if (fillArea[currentY][currentX] > 0) {\n          continue;\n        }\n        var west = 0,\n            east = 0;\n        while (west <= currentX && fillArea[currentY][currentX - west] < 1) {\n          west++;\n        }\n        west--;\n        var traverseX = currentX + east - west;\n        while (east - west + currentX < fillAreaWidth * 3 && fillArea[currentY][traverseX] < 1) {\n          fillArea[currentY][traverseX] = 1;\n          if (currentY > 0 && fillArea[currentY - 1][traverseX] < 1) {\n            queueX.push(currentX + east - west);\n            queueY.push(currentY - 1);\n          }\n          if (currentY < fillAreaHeight * 3 - 1 && fillArea[currentY + 1][traverseX] < 1) {\n            queueX.push(currentX + east - west);\n            queueY.push(currentY + 1);\n          }\n          east++;\n          traverseX = currentX + east - west;\n        }\n      }\n\n      // 9-point merge\n      for (var _y = 0; _y < fillAreaHeight; _y++) {\n        for (var _x2 = 0; _x2 < fillAreaWidth; _x2++) {\n          if (fillArea[_y * 3 + 1][_x2 * 3 + 1] > 0) {\n            var gx = _x2 + fillAreaOffsetX;\n            var gy = _y + fillAreaOffsetY;\n            var grid = this._grid[gy][gx];\n            if (grid.lineOwner > 0 && grid.lineOwner != partyId && lineHitParties.indexOf(grid.lineOwner) < 0) {\n              lineHitParties.push(grid.lineOwner);\n            }\n            grid.lineOwner = 0;\n            if (grid.owner != partyId) {\n              grid.owner = partyId;\n            }\n          }\n        }\n      }\n      this._updateEdges(fillAreaOffsetX - 1, fillAreaOffsetY - 1, fillAreaOffsetX + fillAreaWidth + 1, fillAreaOffsetY + fillAreaHeight + 1);\n\n      // Dispatch onOccupy\n      for (var _i2 = 0; _i2 < this._onOccupyHandler.length; _i2++) {\n        this._onOccupyHandler[_i2](partyId);\n      }\n\n      for (var _i3 = 0; _i3 < lineHitParties.length; _i3++) {\n        for (var j = 0; j < this._onHitLineHandler.length; j++) {\n          this.removeLine(lineHitParties[_i3]);\n          this._onHitLineHandler[j](partyId, lineHitParties[_i3]);\n        }\n      }\n    }\n  }, {\n    key: \"_updateEdges\",\n    value: function _updateEdges(startX, startY, endX, endY) {\n      startX = Math.max(startX || 0, 0);\n      startY = Math.max(startY || 0, 0);\n      endX = Math.min(endX || this._width, this._width);\n      endY = Math.min(endY || this._height, this._height);\n      for (var y = startY; y < endY; y++) {\n        for (var x = startX; x < endX; x++) {\n          var grid = this._grid[y][x];\n          if (grid.owner < 1) {\n            continue;\n          }\n          this._edgeGrid[y][x] = 0;\n          var js = y < 1 ? 0 : -1,\n              je = y >= this._height - 1 ? 0 : 1;\n          var ks = x < 1 ? 0 : -1,\n              ke = x >= this._width - 1 ? 0 : 1;\n          for (var j = js; j <= je; j++) {\n            for (var k = ks; k <= ke; k++) {\n              if (this._grid[y + j][x + k].owner != grid.owner) {\n                this._edgeGrid[y][x] = grid.owner;\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_adjacentLinedTiles\",\n    value: function _adjacentLinedTiles(targetTile) {\n      var detectEdge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (!this._tileChecker) {\n        this._tileChecker = [1, 0, -1, 0, 0, 1, 0, -1];\n      }\n      var adjacentTiles = [];\n      for (var i = 0; i < 4; i++) {\n        var x = targetTile.x + this._tileChecker[i * 2];\n        var y = targetTile.y + this._tileChecker[i * 2 + 1];\n        if (x >= 0 && x < this._width && y >= 0 && y < this._height) {\n          var tile = this._grid[y][x];\n          if (tile.lineOwner == targetTile.owner && tile.lineOwner > 0 || detectEdge && this._edgeGrid[y][x] == targetTile.owner && tile.owner == targetTile.owner) {\n            adjacentTiles.push(tile);\n          }\n        }\n      }\n      return adjacentTiles;\n    }\n  }, {\n    key: \"_getLineSubcode\",\n    value: function _getLineSubcode(direction, nextDirection) {\n      // Forward, march\n      if (direction == nextDirection) {\n        if (direction == 1 || direction == 3) {\n          return 1;\n        } else {\n          return 2;\n        }\n      }\n\n      // Righttime, march\n      else {\n          if (direction == 0 && nextDirection == 1 || direction == 3 && nextDirection == 2) {\n            return 3;\n          } else if (direction == 3 && nextDirection == 0 || direction == 2 && nextDirection == 1) {\n            return 4;\n          } else if (direction == 2 && nextDirection == 3 || direction == 1 && nextDirection == 0) {\n            return 5;\n          } else {\n            return 6;\n          }\n        }\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      return this._width;\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this._height;\n    }\n  }, {\n    key: \"ownership\",\n    get: function get() {\n      return this._grid;\n    }\n  }, {\n    key: \"line\",\n    get: function get() {\n      return this._line;\n    }\n  }]);\n\n  return StageTerritory;\n}();\n\nexports.default = StageTerritory;\n\nvar TerritoryTile = function TerritoryTile(x, y) {\n  _classCallCheck(this, TerritoryTile);\n\n  this.x = x;\n  this.y = y;\n  this.owner = 0;\n  this.lineOwner = 0;\n  this.lineCode = 0;\n};\n\n//# sourceURL=webpack:///./src/cli-core/StageTerritory.js?");

/***/ }),

/***/ "./src/cli-core/StageTimer.js":
/*!************************************!*\
  !*** ./src/cli-core/StageTimer.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Configuration = __webpack_require__(/*! ./Configuration.js */ \"./src/cli-core/Configuration.js\");\n\nvar _Configuration2 = _interopRequireDefault(_Configuration);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar StageTimer = function () {\n  function StageTimer(seconds) {\n    _classCallCheck(this, StageTimer);\n\n    this._timeTotal = seconds;\n    this._timeElapsed = 0;\n    this._expired = false;\n\n    this._onTimeDoneHandlers = [];\n  }\n\n  _createClass(StageTimer, [{\n    key: \"onTimeDone\",\n    value: function onTimeDone(handler) {\n      this._onTimeDoneHandlers.push(handler);\n    }\n  }, {\n    key: \"update\",\n    value: function update(deltaTime) {\n      if (this._expired) {\n        return;\n      }\n\n      this._timeElapsed += deltaTime / 60;\n      if (this._timeElapsed >= this._timeTotal) {\n        this._expired = true;\n        for (var i = 0; i < this._onTimeDoneHandlers.length; i++) {\n          this._onTimeDoneHandlers[i]();\n        }\n        return;\n      }\n    }\n  }, {\n    key: \"_initializeTimer\",\n    value: function _initializeTimer() {\n      this._timeElapsed = 0;\n      this._expired = false;\n    }\n  }]);\n\n  return StageTimer;\n}();\n\nexports.default = StageTimer;\n\n//# sourceURL=webpack:///./src/cli-core/StageTimer.js?");

/***/ }),

/***/ "./src/cli-core/Ticker.js":
/*!********************************!*\
  !*** ./src/cli-core/Ticker.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Ticker = function () {\n  function Ticker() {\n    _classCallCheck(this, Ticker);\n\n    this.targetFPMS = 0.06;\n    this.targetElapsedMS = 16.66;\n    this.deltaTime = 1;\n    this.lastTime = -1;\n    this.started = false;\n    this.currentTimer = null;\n    this.handlers = [];\n  }\n\n  _createClass(Ticker, [{\n    key: \"add\",\n    value: function add(fn) {\n      this.handlers.push(fn);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(fn) {\n      var idx = this.handlers.indexOf(fn);\n      if (idx >= 0) this.handlers.splice(idx, 1);\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this = this;\n\n      if (this.currentTimer === null && !this.started) {\n        this.started = true;\n        this.lastTime = Date.now();\n        this.currentTimer = setTimeout(function () {\n          return _this._tick();\n        }, this.targetElapsedMS);\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.started) {\n        this.started = false;\n        this.lastTime = Date.now();\n        clearTimeout(this.currentTimer);\n        this.currentTimer = null;\n      }\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      this.stop();\n      this.handlers = null;\n    }\n  }, {\n    key: \"_tick\",\n    value: function _tick() {\n      var _this2 = this;\n\n      this.currentTimer = null;\n      if (this.started) {\n        this._update();\n        if (this.started && this.currentTimer === null) {\n          this.currentTimer = setTimeout(function () {\n            return _this2._tick();\n          }, this.targetElapsedMS);\n        }\n      }\n    }\n  }, {\n    key: \"_update\",\n    value: function _update() {\n      var currentTime = Date.now();\n\n      if (currentTime > this.lastTime) {\n\n        this.elapsedMS = currentTime - this.lastTime;\n        this.deltaTime = this.elapsedMS * this.targetFPMS;\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this.handlers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var fn = _step.value;\n\n            fn(this.deltaTime);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      this.lastTime = currentTime;\n    }\n  }]);\n\n  return Ticker;\n}();\n\nexports.default = Ticker;\n\n//# sourceURL=webpack:///./src/cli-core/Ticker.js?");

/***/ }),

/***/ "./src/server.js":
/*!***********************!*\
  !*** ./src/server.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _mysql = __webpack_require__(/*! mysql */ \"mysql\");\n\nvar _mysql2 = _interopRequireDefault(_mysql);\n\nvar _Connection = __webpack_require__(/*! ./Connection */ \"./src/Connection.js\");\n\nvar _Connection2 = _interopRequireDefault(_Connection);\n\nvar _Ticker = __webpack_require__(/*! ./cli-core/Ticker */ \"./src/cli-core/Ticker.js\");\n\nvar _Ticker2 = _interopRequireDefault(_Ticker);\n\nvar _QueryHandler = __webpack_require__(/*! ./QueryHandler */ \"./src/QueryHandler.js\");\n\nvar _QueryHandler2 = _interopRequireDefault(_QueryHandler);\n\nvar _UpdateHandler = __webpack_require__(/*! ./UpdateHandler */ \"./src/UpdateHandler.js\");\n\nvar _UpdateHandler2 = _interopRequireDefault(_UpdateHandler);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_Connection2.default.setup();\n\n// game room list\nvar rooms = _Connection2.default.rooms;\n\n// game user list\nvar users = _Connection2.default.users;\n\n// socket connection\nvar io = _Connection2.default.io;\n\n// user match find queue\nvar waitingQueues = {\n  soloTwo: [],\n  soloFour: [],\n  teamFour: []\n\n  // set timeout\n  // var RECONNECT_TIMEOUT = 5;\n\n  // Timer for real-time update\n};var ticker = new _Ticker2.default();\nticker.start();\nticker.add(function () {\n  update();\n});\n\n// update function\nfunction update() {\n  rooms.update(ticker.deltaTime);\n}\n\nfunction conditionQueryString(column, value) {\n  return column + \" = \" + \"'\" + value + \"'\";\n}\n\nio.on(\"connection\", function (socket) {\n\n  // new socket\n  console.log(\"Connection to socket <%s> established\", socket.id);\n\n  /*   // session check\n    socket.on(\"restore session\", (data) => {\n  \n      if (users.exists(data.userId)) {\n  \n        // find user with client session user id\n        let user = users.getById(data.userId);\n  \n        // conduct user restore process\n        user.unsetTimer();\n        user.socketId = socket.id;\n  \n        let userData = {\n          success: true,\n          userId: user.id\n        };\n  \n        let room = rooms.getById(user.playingRoomId);\n        if (room) userData.roomData = {id: room.id, players: room.connectedPlayers()};\n  \n        socket.emit(\"restore session\", userData);\n  \n        console.log(\"user <%s> restored\", user.id);\n  \n      } else {\n  \n        socket.emit(\"restore session\", {\n          success: false,\n          error: \"connection expired\"\n        });\n  \n      }\n  \n    }); */\n\n  // sign up\n  socket.on(\"creat user\", function (data) {\n\n    /**\n     * id : id input\n     * password : password input\n     */\n\n    var connnectionData = {\n      socket: socket,\n      db: _Connection2.default.db,\n      users: users,\n      data: data\n    };\n\n    var queryData = {\n      table: \"user\",\n      condition: null,\n      contents: null\n    };\n\n    _QueryHandler2.default.selectQuery(connnectionData, queryData, _UpdateHandler2.default.signUp);\n  });\n\n  // sign in\n  socket.on(\"establish session\", function (data) {\n\n    /**\n     * id : id input\n     * password : password input\n     * isAuto : auto sign in bool\n     */\n\n    var connnectionData = {\n      socket: socket,\n      db: _Connection2.default.db,\n      users: users,\n      data: data\n    };\n\n    var queryData = {\n      table: \"user\",\n      condition: null,\n      contents: null\n    };\n\n    _QueryHandler2.default.selectQuery(connnectionData, queryData, _UpdateHandler2.default.signIn);\n  });\n\n  // after sign in, send user's data\n  socket.on(\"fetch user\", function (data) {\n\n    /**\n     * userId : user who requested\n     */\n\n    var connnectionData = {\n      socket: socket,\n      db: _Connection2.default.db,\n      users: users,\n      data: data\n    };\n\n    var queryData = {\n      table: \"user_gamedata\",\n      condition: conditionQueryString(\"user_id\", data.userId),\n      contents: null\n    };\n\n    _QueryHandler2.default.selectQuery(connnectionData, queryData, _UpdateHandler2.default.sendUserData);\n  });\n\n  // update user data\n  socket.on(\"update user\", function (data) {\n\n    /**\n     * userId : user who requested\n     * contents : user data that need to be updated\n     */\n\n    // check user validation\n    if (users.getById(data.userId).socketId != socket.id) {\n      console.log(\"Unverified request from <%s>\", data.userId);\n      return;\n    }\n\n    var connnectionData = {\n      socket: socket,\n      db: _Connection2.default.db,\n      users: users,\n      data: data\n    };\n\n    var queryData = {\n      table: \"user_gamedata\",\n      condition: conditionQueryString(\"user_id\", data.userId),\n      contents: data.contents\n    };\n\n    _QueryHandler2.default.updateQuery(connnectionData, queryData);\n  });\n\n  // find match\n  socket.on(\"find match\", function (data) {\n\n    /**\n     * userId : user who requested\n     * playerCounts : room player counts\n     * isTeam : weather team match bool\n     */\n\n    var user = users.getById(data.userId);\n\n    // check user status\n    if (user.status != \"ready\") return;\n\n    console.log(\"request for finding match from <%s>\", data.userId);\n\n    // make new room in room list\n    var room = rooms.create(data.playerCounts, data.isTeam, [user]);\n    console.log(\"<%s> room created for: <%s>\", room.id, user.id);\n\n    // enroll user in the room\n    user.playingRoomId = room.id;\n    user.status = \"play\";\n\n    // send success massage\n    var partyList = [];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = room.stage.parties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var party = _step.value;\n\n        partyList.push({\n          id: party.id,\n          userId: party.userId,\n          territoryColor: party.territoryColor,\n          deckCode: party.deckCode,\n          isAi: party.false\n        });\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    room.broadcast(\"find match\", {\n      success: true,\n      roomData: {\n        id: room.id,\n        seed: room.seed,\n        players: room.players,\n        parties: partyList\n      }\n    });\n\n    /* \n        // distinguish user's target game category\n        let currentQueue;\n        if (data.isTeam) {\n          currentQueue = waitingQueues.teamFour;\n        } else {\n          if (data.playerCounts === 4) {\n            currentQueue = waitingQueues.soloFour;\n          } else if (data.playerCounts === 2) {\n            currentQueue = waitingQueues.soloTwo;\n          }\n        }\n    \n        // add to waiting queue\n        currentQueue.push(user);\n    \n        // change user status\n        user.status = \"wait\";\n    \n        if (currentQueue.length === data.playerCounts) {\n          \n          // make new room in room list\n          let room = rooms.create(data.playerCounts, data.isTeam);\n          console.log(\"<%s> room created for:\", room.id);\n    \n          // push players in room's player list\n          let queueLength = currentQueue.length;\n    \n          for (let i = 0; i < queueLength; i++) {\n            let player = currentQueue.shift();\n            room.players.push(player);\n            player.playingRoomId = room.id;\n            player.status = \"play\";\n            console.log(player.id);\n          }\n    \n          // send success massage\n          room.broadcast(\"find match\", {\n            success: true,\n            roomData: {\n              id: room.id,\n              players: room.connectedPlayers()\n            }\n          });\n    \n        } */\n  });\n\n  socket.on(\"cancel finding\", function (data) {\n\n    /**\n     * userId : user who requested\n     * playerCounts : room player counts\n     * isTeam : weather team match bool\n     */\n\n    // check user status\n    if (users.getById(data.userId).status != \"wait\") return;\n\n    console.log(\"cancel request for finding match from <%s>\", data.userId);\n\n    // change user status\n    users.getById(data.userId).status = \"ready\";\n\n    // delete user from queue\n    var keys = Object.keys(waitingQueues);\n\n    for (var i = 0; i < keys.length; i++) {\n      var index = waitingQueues[keys[i]].indexOf(users.getById(data.userId));\n      if (index != -1) {\n        waitingQueues[keys[i]].splice(index, 1);\n      }\n    }\n\n    // socket.emit(\"cancel finding\", {\n    //   success: true\n    // });\n  });\n\n  socket.on(\"end game\", function (data) {\n\n    /**\n     * userId: userId,\n     * userRank: userRank,\n     * rank: userId rank list,\n     * stats: kills, relics, score, lives\n     */\n\n    var user = users.getById(data.userId);\n\n    // check user status\n    if (user.status != \"play\") return;\n\n    console.log(\"end game request from <%s>\", data.userId);\n\n    var connnectionData = {\n      socket: socket,\n      db: _Connection2.default.db,\n      users: users,\n      data: data\n    };\n\n    var room = rooms.getById(user.playingRoomId);\n\n    room.deleteUserFromRoom(user.id);\n\n    var rewards = [];\n    var totalCoin = 0;\n    var characterCode = Math.floor(Math.random() * 22);\n\n    rewards.push({\n      type: \"character\",\n      characterData: characterCode\n    });\n\n    for (var i = 0; i < 2; i++) {\n      var coinIncrement = Math.floor(Math.random() * 10) * 5 + 50;\n      Math.random() > 0.5 ? rewards.push({ type: \"coin\", amount: coinIncrement }) : rewards.unshift({ type: \"coin\", amount: coinIncrement });\n      totalCoin += coinIncrement;\n    };\n\n    var coinQueryString = \"`coin` + \" + totalCoin;\n    //let cardQueryString = \"CONCAT(`card`, `\" + characterCode + \"`)\";\n\n    _QueryHandler2.default.updateQuery(connnectionData, {\n      table: \"user_gamedata\",\n      contents: {\n        coin: _mysql2.default.raw(coinQueryString)\n        //card: mysql.raw(cardQueryString)\n      },\n      condition: conditionQueryString(\"user_id\", user.id)\n    });\n\n    _QueryHandler2.default.updateQuery(connnectionData, {\n      table: \"user_gamestat\",\n      contents: {\n        total_games_played: _mysql2.default.raw(\"`total_games_played` + 1\"),\n        solo_four_games_played: _mysql2.default.raw(\"`solo_four_games_played` + 1\")\n      },\n      condition: conditionQueryString(\"user_id\", user.id)\n    });\n\n    socket.emit(\"end game\", {\n      rewards: rewards\n    });\n\n    if (room.players.length == 0) {\n\n      _QueryHandler2.default.insertQuery(connnectionData, {\n        table: \"gamelog\",\n        contents: {\n          room_id: room.id,\n          rank: data.rank.join(),\n          seed: room.seed\n        }\n      });\n\n      console.log(\"Room <%s> deleted\", room.id);\n      rooms.roomList.splice(rooms.roomList.indexOf(room), 1);\n      rooms.roomIdMap.delete(room.id);\n    }\n  });\n\n  socket.on(\"disconnect\", function () {\n\n    console.log(\"socket <%s> disconnected\", socket.id);\n\n    var connnectionData = {\n      socket: socket,\n      db: _Connection2.default.db,\n      users: users\n    };\n\n    // disconnected user\n    var user = users.getBySocketId(socket.id);\n    if (!user) return;\n\n    // delete socketId from user\n    user.socketId = \"\";\n    console.log(\"user <%s> disconnected\", user.id);\n\n    // if user is finding match\n    if (user.status === \"wait\") {\n\n      // delete user from queue\n      var keys = Object.keys(waitingQueues);\n\n      for (var i = 0; i < keys.length; i++) {\n        var index = waitingQueues[keys[i]].indexOf(user);\n        if (index != -1) {\n          waitingQueues[keys[i]].splice(index, 1);\n        }\n      }\n\n      // change user status\n      user.status = \"ready\";\n    }\n\n    var room = rooms.getById(user.playingRoomId);\n\n    if (room) {\n\n      room.broadcast(\"user disconnected\", {\n        userId: user.id,\n        roomData: {\n          id: room.id,\n          players: room.connectedPlayers()\n        }\n      });\n\n      room.deleteUserFromRoom(user.id);\n\n      if (room.players.length == 0) {\n\n        _QueryHandler2.default.insertQuery(connnectionData, {\n          table: \"gamelog\",\n          contents: {\n            room_id: room.id,\n            seed: room.seed\n          }\n        });\n\n        console.log(\"Room <%s> deleted\", room.id);\n        rooms.roomList.splice(rooms.roomList.indexOf(room), 1);\n        rooms.roomIdMap.delete(room.id);\n      }\n    }\n\n    users.remove(user.id);\n\n    /*     user.setTimer(RECONNECT_TIMEOUT, () => {\n    \n          if (room) {\n    \n            room.broadcast(\"user disconnected\", {\n              userId: user.id,\n              roomData: {\n                id: room.id,\n                players: room.connectedPlayers()\n              }\n            });\n    \n          }\n    \n          users.remove(user.id);\n    \n        }); */\n  });\n\n  // change direction\n\n  //socket.on(\"change direction\", (data) => {\n\n  /**\n   * roomId: roomId\n   * pratyId: partyId\n   * direction: direction\n   * coordinate: coordinate\n   */\n\n  //  for (let party of rooms.getById(data.roomId).stage.parties) {\n  //    if (party.id == data.pratyId) {\n  //      party.scheduleDirection(data.direction, data.coordinate);\n  //    }\n  //  }\n\n\n  //});\n});\n\n//# sourceURL=webpack:///./src/server.js?");

/***/ }),

/***/ "./src/setting.js":
/*!************************!*\
  !*** ./src/setting.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar settings = {\n  db: {\n    host: \"13.209.96.210\",\n    user: \"root\",\n    password: \"qwe123\",\n    database: \"spring-party\"\n  }\n};\n\nexports.default = settings;\n\n//# sourceURL=webpack:///./src/setting.js?");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"crypto\");\n\n//# sourceURL=webpack:///external_%22crypto%22?");

/***/ }),

/***/ "easystarjs":
/*!*****************************!*\
  !*** external "easystarjs" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"easystarjs\");\n\n//# sourceURL=webpack:///external_%22easystarjs%22?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack:///external_%22fs%22?");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"http\");\n\n//# sourceURL=webpack:///external_%22http%22?");

/***/ }),

/***/ "mysql":
/*!************************!*\
  !*** external "mysql" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"mysql\");\n\n//# sourceURL=webpack:///external_%22mysql%22?");

/***/ }),

/***/ "nick-generator":
/*!*********************************!*\
  !*** external "nick-generator" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"nick-generator\");\n\n//# sourceURL=webpack:///external_%22nick-generator%22?");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");\n\n//# sourceURL=webpack:///external_%22path%22?");

/***/ }),

/***/ "random-seed":
/*!******************************!*\
  !*** external "random-seed" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"random-seed\");\n\n//# sourceURL=webpack:///external_%22random-seed%22?");

/***/ }),

/***/ "socket.io":
/*!****************************!*\
  !*** external "socket.io" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"socket.io\");\n\n//# sourceURL=webpack:///external_%22socket.io%22?");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"url\");\n\n//# sourceURL=webpack:///external_%22url%22?");

/***/ })

/******/ });